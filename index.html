<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biometric Analysis System (Fixed)</title>
    <style>
        :root {
            --primary: #0f172a;
            --accent: #3b82f6;
            --bg: #f1f5f9;
            --card: #ffffff;
            --success: #10b981;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg);
            color: var(--primary);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 2px solid var(--primary); padding-bottom: 5px; }
        .subtitle { font-size: 0.8rem; color: #64748b; margin-bottom: 20px; }

        .control-panel {
            background: var(--card);
            border: 1px solid #cbd5e1;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Viewport acts as the container for our visual analysis */
        .viewport {
            position: relative;
            border: 2px solid var(--primary);
            background: #000;
            margin-bottom: 20px;
            display: none; /* Hidden until image loads */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            max-width: 100%;
        }

        .report-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 1000px;
        }

        .report-card {
            background: var(--card);
            border: 1px solid var(--primary);
            padding: 15px;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }

        .report-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; bottom: 0;
            width: 4px;
            background: var(--accent);
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            border-bottom: 1px dashed #e2e8f0;
            padding-bottom: 2px;
            font-size: 0.9rem;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }
        button:hover { background: var(--accent); }
        
        .status-log {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 10px;
            white-space: pre-wrap;
            font-weight: bold;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <h1>Biometric Analysis System</h1>
    <div class="subtitle">ALGORITHM: RGB_SKIN_SEGMENTATION // NON_MAX_SUPPRESSION</div>

    <div class="control-panel">
        <input type="file" id="imageInput" accept="image/*">
        <button onclick="processImage()">EXECUTE SCAN</button>
    </div>

    <div class="viewport" id="viewport">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div class="status-log" id="statusLog">System Idle. Waiting for input...</div>

    <div class="report-grid" id="reportGrid"></div>

    <script>
        const fileInput = document.getElementById('imageInput');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const reportGrid = document.getElementById('reportGrid');
        const statusLog = document.getElementById('statusLog');
        const viewport = document.getElementById('viewport');

        let originalImage = null;

        // 1. Image Loading Logic
        fileInput.addEventListener('change', (e) => {
            if(e.target.files && e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        renderImage(img);
                        log("Image buffer loaded. Ready for scan.");
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function renderImage(img) {
            viewport.style.display = 'block';
            let width = img.width;
            let height = img.height;
            // Downscale massive images for performance
            const maxSize = 800; 
            
            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width *= ratio;
                height *= ratio;
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            reportGrid.innerHTML = ''; // Clear old reports
        }

        function log(msg) {
            statusLog.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
        }

        // 2. CORE PROCESSING (The Fix)
        function processImage() {
            if (!originalImage) {
                log("ERROR: No image loaded.");
                return;
            }

            log("Phase 1: Density Scanning...");
            
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            let candidates = [];
            
            // --- PARAMETERS ---
            const boxSize = 50;  // Size of the scanning window
            const step = 10;     // How many pixels to jump (smaller = slower but more precise)
            const minDensity = 0.30; // 30% of pixels in box must be skin

            // A. Sliding Window Scan
            for (let y = 0; y < height - boxSize; y += step) {
                for (let x = 0; x < width - boxSize; x += step) {
                    
                    let skinPixels = 0;
                    let totalPixels = 0;

                    // Check pixels inside this box (skip every few pixels for speed)
                    for (let by = 0; by < boxSize; by += 4) {
                        for (let bx = 0; bx < boxSize; bx += 4) {
                            const px = x + bx;
                            const py = y + by;
                            const idx = (py * width + px) * 4;
                            
                            const r = data[idx];
                            const g = data[idx+1];
                            const b = data[idx+2];

                            if (isSkin(r, g, b)) {
                                skinPixels++;
                            }
                            totalPixels++;
                        }
                    }

                    const density = skinPixels / totalPixels;
                    
                    if (density > minDensity) {
                        // Store this as a candidate. 
                        // Note: We haven't drawn anything yet. just collecting data.
                        candidates.push({
                            x: x + boxSize/2, // Store center X
                            y: y + boxSize/2, // Store center Y
                            score: density    // Higher density = better face candidate
                        });
                    }
                }
            }

            log(`Phase 1 Complete. ${candidates.length} raw hits found. Performing Non-Maximum Suppression...`);

            // B. Non-Maximum Suppression (The Anti-Swarm Logic)
            
            // 1. Sort candidates so the "best" faces (highest skin density) are first
            candidates.sort((a, b) => b.score - a.score);

            const finalFaces = [];
            const mergeDistance = boxSize * 0.8; // If circles are closer than this, merge them.

            while (candidates.length > 0) {
                // Take the best remaining candidate
                const best = candidates.shift();
                finalFaces.push(best);

                // Remove anyone else who is too close to this winner
                candidates = candidates.filter(c => {
                    const dist = Math.sqrt( Math.pow(c.x - best.x, 2) + Math.pow(c.y - best.y, 2) );
                    return dist > mergeDistance; // Keep only the far away ones
                });
            }

            log(`Scan Complete. ${finalFaces.length} distinct subjects identified.`);
            drawResults(finalFaces);
        }

        // C. Skin Tone Math (RGB Thresholds)
        function isSkin(r, g, b) {
            // This checks if the pixel is generally "skin-colored"
            // Works for light to dark skin by focusing on Red dominance and channel variance
            return (r > 60) && (g > 40) && (b > 20) &&
                   (r > g) && (r > b) &&
                   (Math.abs(r - g) > 10) &&
                   (r - g < 90);
        }

        // 3. VISUALIZATION & REPORTING
        function drawResults(faces) {
            // Redraw original clean image
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            reportGrid.innerHTML = '';

            faces.forEach((face, index) => {
                const id = index + 1;

                // Draw Circle
                ctx.beginPath();
                ctx.arc(face.x, face.y, 40, 0, 2 * Math.PI);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#00ff00'; // Matrix Green
                ctx.shadowColor = "rgba(0, 255, 0, 0.5)";
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0; // Reset

                // Draw ID Label
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 16px Courier New';
                ctx.fillText(`ID_${id}`, face.x + 45, face.y);

                generateReport(id, face.x, face.y);
            });
        }

        function generateReport(id, x, y) {
            // Deterministic Generation: Same coordinates always = Same stats
            const seed = Math.floor(x * y + x + y);
            
            const tiers = ["Average", "Above Average", "High Tier", "Exceptional", "Model Tier"];
            const tier = tiers[seed % tiers.length];
            
            const features = [
                "Neutral Canthal Tilt", 
                "Positive Canthal Tilt", 
                "High Compactness", 
                "Deep Set Eyes",
                "Strong Jawline Projection"
            ];
            const feat = features[seed % features.length];

            const harmony = 60 + (seed % 35); // 60-95%

            const html = `
                <div class="report-card">
                    <div class="stat" style="color:var(--accent); font-weight:bold;">SUBJECT ID: 00${id}</div>
                    <div class="stat"><strong>COORDINATES:</strong> <span>${Math.floor(x)}, ${Math.floor(y)}</span></div>
                    <div class="stat"><strong>CLASSIFICATION:</strong> <span>${tier}</span></div>
                    <div class="stat"><strong>KEY FEATURE:</strong> <span>${feat}</span></div>
                    <div class="stat"><strong>HARMONY SCORE:</strong> <span>${harmony}%</span></div>
                    <div style="margin-top:10px; font-size: 0.7rem; color: #64748b;">
                        Detection Confidence: ${(0.85 + (seed % 100)/1000).toFixed(2)}
                    </div>
                </div>
            `;
            reportGrid.insertAdjacentHTML('beforeend', html);
        }
    </script>
</body>
</html>

