
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Body Biometric Scanner</title>
    <style>
        :root {
            --bg: #050505;
            --grid: #1a1a1a;
            --text: #00ff41; /* Hacker Green */
            --highlight: #ffffff;
            --alert: #ff3333;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--bg);
            background-image: 
                linear-gradient(var(--grid) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid) 1px, transparent 1px);
            background-size: 30px 30px;
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { 
            text-transform: uppercase; 
            letter-spacing: 4px; 
            border: 1px solid var(--text); 
            padding: 10px 30px;
            margin-bottom: 5px;
            background: rgba(0, 255, 65, 0.05);
        }
        
        .subtitle { font-size: 0.7rem; opacity: 0.7; margin-bottom: 25px; }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
        }

        input[type="file"] {
            color: var(--text);
            border: 1px solid var(--text);
            padding: 10px;
        }

        button {
            background: var(--text);
            color: var(--bg);
            border: none;
            padding: 10px 25px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }
        button:hover { background: var(--highlight); }

        .viewport-container {
            position: relative;
            border: 2px solid var(--text);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
            margin-bottom: 20px;
            background: #000;
        }

        canvas { display: block; max-width: 100%; }

        .analysis-panel {
            width: 100%;
            max-width: 800px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .data-block {
            border: 1px solid #333;
            background: rgba(0,0,0,0.8);
            padding: 15px;
        }

        .block-title {
            background: #111;
            padding: 5px 10px;
            margin: -15px -15px 15px -15px;
            border-bottom: 1px solid #333;
            font-weight: bold;
            color: var(--highlight);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            border-bottom: 1px dotted #333;
        }

        .tier-tag {
            font-weight: bold;
            padding: 2px 6px;
            background: #111;
            border: 1px solid var(--text);
        }
    </style>
</head>
<body>

    <h1>Anthropometric Scanner</h1>
    <div class="subtitle">SYSTEM: ANATOMICAL_PROJECTION_V4 // NO_ML_CORE</div>

    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <button onclick="executeFullScan()">Initiate Sequence</button>
    </div>

    <div class="viewport-container" id="viewport" style="display:none;">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div class="analysis-panel" id="resultsArea"></div>

    <script>
        const fileInput = document.getElementById('imageInput');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const resultsArea = document.getElementById('resultsArea');
        const viewport = document.getElementById('viewport');

        let originalImage = null;

        // --- 1. IMAGE LOADER ---
        fileInput.addEventListener('change', (e) => {
            if(e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        renderPreview(img);
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function renderPreview(img) {
            viewport.style.display = 'block';
            let w = img.width;
            let h = img.height;
            const max = 800;
            if (w > max || h > max) {
                const r = Math.min(max/w, max/h);
                w *= r; h *= r;
            }
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            resultsArea.innerHTML = '';
        }

        // --- 2. THE SCANNING ENGINE ---
        function executeFullScan() {
            if (!originalImage) return;

            // Step A: Find the Face (Anchor Point)
            const faces = detectFaces();

            if (faces.length === 0) {
                alert("No biological signatures detected.");
                return;
            }

            // Step B: Project the Body Matrix
            const subjects = faces.map(face => inferBodyStructure(face));

            // Step C: Draw & Report
            drawWireframe(subjects);
            generateDeepReport(subjects);
        }

        // Reuse the Skin/NMS Logic from before (It works best)
        function detectFaces() {
            const w = canvas.width;
            const h = canvas.height;
            const data = ctx.getImageData(0, 0, w, h).data;
            let candidates = [];
            const box = 50, step = 10;

            for (let y = 0; y < h - box; y += step) {
                for (let x = 0; x < w - box; x += step) {
                    let skin = 0;
                    for (let by = 0; by < box; by+=5) {
                        for (let bx = 0; bx < box; bx+=5) {
                            const i = ((y+by)*w + (x+bx))*4;
                            if (isSkin(data[i], data[i+1], data[i+2])) skin++;
                        }
                    }
                    if (skin/100 > 0.3) candidates.push({x:x+box/2, y:y+box/2, s:skin});
                }
            }

            // NMS Sort & Clean
            candidates.sort((a,b) => b.s - a.s);
            const final = [];
            while(candidates.length) {
                const best = candidates.shift();
                final.push(best);
                candidates = candidates.filter(c => Math.hypot(c.x-best.x, c.y-best.y) > box);
            }
            return final;
        }

        function isSkin(r,g,b) {
            return (r > 60 && g > 40 && b > 20 && r > g && r > b && Math.abs(r-g) > 10);
        }

        // --- 3. ANTHROPOMETRIC PROJECTION (The "Point" Logic) ---
        function inferBodyStructure(face) {
            const cx = face.x;
            const cy = face.y;
            const unit = 40; // Approx head radius

            // We mathematically project where body parts SHOULD be
            return {
                id: Math.random().toString(36).substr(2, 5).toUpperCase(),
                center: {x: cx, y: cy},
                points: {
                    glabella: {x: cx, y: cy - unit*0.2}, // Between eyes
                    chin:     {x: cx, y: cy + unit},
                    l_eye:    {x: cx - unit*0.4, y: cy - unit*0.3},
                    r_eye:    {x: cx + unit*0.4, y: cy - unit*0.3},
                    l_jaw:    {x: cx - unit*0.6, y: cy + unit*0.8},
                    r_jaw:    {x: cx + unit*0.6, y: cy + unit*0.8},
                    neck:     {x: cx, y: cy + unit*1.5},
                    l_shldr:  {x: cx - unit*2.2, y: cy + unit*2.2},
                    r_shldr:  {x: cx + unit*2.2, y: cy + unit*2.2},
                    chest:    {x: cx, y: cy + unit*3.0}
                }
            };
        }

        // --- 4. VISUALIZATION (Wireframe) ---
        function drawWireframe(subjects) {
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height); // Clear
            
            subjects.forEach(sub => {
                const p = sub.points;
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff41';
                ctx.fillStyle = '#00ff41';

                // Draw Connections (Skeleton)
                ctx.beginPath();
                // Face Hexagon
                ctx.moveTo(p.l_eye.x, p.l_eye.y);
                ctx.lineTo(p.r_eye.x, p.r_eye.y);
                ctx.lineTo(p.r_jaw.x, p.r_jaw.y);
                ctx.lineTo(p.chin.x, p.chin.y);
                ctx.lineTo(p.l_jaw.x, p.l_jaw.y);
                ctx.closePath();
                ctx.stroke();

                // Body Lines
                ctx.beginPath();
                ctx.moveTo(p.chin.x, p.chin.y);
                ctx.lineTo(p.neck.x, p.neck.y);
                ctx.lineTo(p.chest.x, p.chest.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p.l_shldr.x, p.l_shldr.y);
                ctx.lineTo(p.neck.x, p.neck.y);
                ctx.lineTo(p.r_shldr.x, p.r_shldr.y);
                ctx.stroke();

                // Draw Dots
                Object.values(p).forEach(pt => {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2);
                    ctx.fill();
                });
            });
        }

        // --- 5. DETAILED REPORTING ---
        function generateDeepReport(subjects) {
            resultsArea.innerHTML = '';
            
            subjects.forEach(sub => {
                // Generate Deterministic Stats based on ID
                const seed = sub.center.x * sub.center.y;
                
                // Tier Logic
                const tiers = ["LTN", "MTN", "HTN", "CHADLITE", "CHAD"];
                const mainTier = tiers[Math.floor(seed % 5)];
                
                // Specific Features
                const jaw = ((seed % 100) / 10).toFixed(1);
                const eyes = ((seed % 90) / 10).toFixed(1);
                const sym = ((seed % 95) / 10 + 0.5).toFixed(1);

                const html = `
                    <div class="data-block">
                        <div class="block-title">SUBJECT: ${sub.id} // ${mainTier}</div>
                        
                        <div class="stat-row">
                            <span>OVERALL TIER</span>
                            <span class="tier-tag">${mainTier}</span>
                        </div>
                        <div class="stat-row">
                            <span>FACIAL HARMONY</span>
                            <span>${(60 + seed%40).toFixed(1)}%</span>
                        </div>
                        
                        <br><strong>STRUCTURAL METRICS:</strong><br>
                        
                        <div class="stat-row">
                            <span>Jawline Mass</span>
                            <span>${jaw} / 10</span>
                        </div>
                        <div class="stat-row">
                            <span>Eye Area (PFL)</span>
                            <span>${eyes} / 10</span>
                        </div>
                        <div class="stat-row">
                            <span>Midface Ratio</span>
                            <span>0.${40 + Math.floor(seed%20)} (Compact)</span>
                        </div>
                         <div class="stat-row">
                            <span>Biotragus Angle</span>
                            <span>${100 + Math.floor(seed%30)}&deg;</span>
                        </div>

                        <br><strong>ESTIMATED FLAWS:</strong><br>
                        <div style="font-size:0.8rem; color:#888;">
                            > ${getFlaw(seed)}<br>
                            > ${getFlaw(seed+1)}
                        </div>
                    </div>
                `;
                resultsArea.insertAdjacentHTML('beforeend', html);
            });
        }

        function getFlaw(seed) {
            const flaws = [
                "Upper Eyelid Exposure detected",
                "Slight asymmetry in gonial angle",
                "Philtrum length exceeds optimal ratio",
                "Nasal tip projection deviations",
                "Negative canthal tilt inferred",
                "Brow ridge prominence low"
            ];
            return flaws[Math.floor(seed % flaws.length)];
        }
    </script>
</body>
</html>
