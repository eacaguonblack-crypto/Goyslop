<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silhouette Contour Scanner</title>
    <style>
        :root {
            --bg: #000000;
            --term: #0d0d0d;
            --line: #00ff00; /* Radar Green */
            --text: #00ff00;
        }

        body {
            font-family: 'Consolas', monospace;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { 
            border-bottom: 2px solid var(--line); 
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .controls {
            margin: 20px 0;
            background: var(--term);
            padding: 15px;
            border: 1px solid #333;
        }

        .viewport {
            position: relative;
            border: 1px solid #333;
            display: none;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
        }

        canvas { display: block; max-width: 100%; }

        .scan-line {
            position: absolute;
            top: 0; left: 0; right: 0; height: 2px;
            background: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px var(--line);
            animation: scan 2s linear infinite;
            pointer-events: none;
        }

        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        .report-area {
            width: 100%; max-width: 800px;
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .report-card {
            border: 1px solid var(--line);
            padding: 15px;
            background: #050505;
        }
        
        .stat { display: flex; justify-content: space-between; border-bottom: 1px dashed #333; margin-bottom: 5px; }

        button {
            background: var(--line); color: black; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; text-transform: uppercase;
        }
        button:hover { background: #ccffcc; }
    </style>
</head>
<body>

    <h1>Silhouette Extraction System</h1>
    <div style="font-size: 0.8em; opacity: 0.7;">ALGORITHM: SOBEL_EDGE_DETECTION // ROI_MASKING</div>

    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <button onclick="runSilhouetteScan()">Trace Silhouette</button>
    </div>

    <div class="viewport" id="viewport">
        <canvas id="mainCanvas"></canvas>
        <div class="scan-line"></div>
    </div>

    <div class="report-area" id="reportArea"></div>

    <script>
        const fileInput = document.getElementById('imageInput');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const viewport = document.getElementById('viewport');
        const reportArea = document.getElementById('reportArea');

        let originalImage = null;

        fileInput.addEventListener('change', (e) => {
            if(e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        renderImage(img);
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function renderImage(img) {
            viewport.style.display = 'block';
            let w = img.width;
            let h = img.height;
            const max = 700; 
            if (w > max || h > max) {
                const r = Math.min(max/w, max/h);
                w *= r; h *= r;
            }
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            reportArea.innerHTML = '';
        }

        // --- MAIN SEQUENCE ---
        function runSilhouetteScan() {
            if (!originalImage) return;

            // 1. Detect Faces (The Anchors)
            const faces = detectFaces();

            // 2. Clear Canvas & Redraw Darkened Image
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw original image but dim it (Low Opacity)
            ctx.globalAlpha = 0.3;
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            if (faces.length === 0) {
                alert("No subjects found to outline.");
                return;
            }

            // 3. Process each person
            faces.forEach((face, idx) => {
                // Draw Silhouette using Sobel inside their Body ROI
                drawSobelContour(face);
                generateReport(face, idx + 1);
            });
        }

        // --- FACE DETECTION (Reuse Robust NMS Logic) ---
        function detectFaces() {
            const w = canvas.width;
            const h = canvas.height;
            // Get data from a temporary canvas to not read the dimmed one
            const tempC = document.createElement('canvas');
            tempC.width = w; tempC.height = h;
            const tempCtx = tempC.getContext('2d');
            tempCtx.drawImage(originalImage, 0, 0, w, h);
            const data = tempCtx.getImageData(0, 0, w, h).data;

            let candidates = [];
            const box = 50, step = 10;

            for (let y = 0; y < h - box; y += step) {
                for (let x = 0; x < w - box; x += step) {
                    let skin = 0;
                    for (let by = 0; by < box; by+=5) {
                        for (let bx = 0; bx < box; bx+=5) {
                            const i = ((y+by)*w + (x+bx))*4;
                            if (isSkin(data[i], data[i+1], data[i+2])) skin++;
                        }
                    }
                    if (skin/100 > 0.35) candidates.push({x:x+box/2, y:y+box/2, s:skin, r:box/2});
                }
            }

            // NMS
            candidates.sort((a,b) => b.s - a.s);
            const final = [];
            while(candidates.length) {
                const best = candidates.shift();
                final.push(best);
                candidates = candidates.filter(c => Math.hypot(c.x-best.x, c.y-best.y) > box);
            }
            return final;
        }

        function isSkin(r,g,b) {
            return (r > 60 && g > 40 && b > 20 && r > g && r > b && Math.abs(r-g) > 10);
        }

        // --- SOBEL EDGE TRACING (The Silhouette Logic) ---
        function drawSobelContour(face) {
            const w = canvas.width;
            const h = canvas.height;
            
            // Define ROI (Region of Interest) - Body is below face
            // We assume body width is ~3x face width, height is ~4x face height
            const faceRad = face.r; 
            const startX = Math.max(0, face.x - faceRad * 2.5);
            const startY = Math.max(0, face.y - faceRad); // Start at forehead
            const endX = Math.min(w, face.x + faceRad * 2.5);
            const endY = Math.min(h, face.y + faceRad * 6); // Go deep down
            
            const rw = endX - startX;
            const rh = endY - startY;

            // Get pixels for this region only (Performance)
            const tempC = document.createElement('canvas');
            tempC.width = w; tempC.height = h;
            const tCtx = tempC.getContext('2d');
            tCtx.drawImage(originalImage, 0, 0, w, h);
            const src = tCtx.getImageData(startX, startY, rw, rh);
            const output = ctx.createImageData(rw, rh);

            const data = src.data;
            const limit = data.length;
            const width = src.width;

            // SOBEL KERNELS
            // Gx = [-1 0 1]
            //      [-2 0 2]
            //      [-1 0 1]
            
            for (let y = 1; y < rh - 1; y++) {
                for (let x = 1; x < rw - 1; x++) {
                    
                    const i = (y * width + x) * 4;

                    // Convert surrounding pixels to grayscale strength
                    // We only need to sample the "luminance"
                    function getLum(offX, offY) {
                        const idx = ((y + offY) * width + (x + offX)) * 4;
                        return (data[idx] + data[idx+1] + data[idx+2]) / 3;
                    }

                    // Apply Sobel Math
                    const gx = (
                        (-1 * getLum(-1,-1)) + (1 * getLum(1,-1)) +
                        (-2 * getLum(-1, 0)) + (2 * getLum(1, 0)) +
                        (-1 * getLum(-1, 1)) + (1 * getLum(1, 1))
                    );

                    const gy = (
                        (-1 * getLum(-1,-1)) + (-2 * getLum(0,-1)) + (-1 * getLum(1,-1)) +
                        ( 1 * getLum(-1, 1)) + ( 2 * getLum(0, 1)) + ( 1 * getLum(1, 1))
                    );

                    const mag = Math.sqrt(gx*gx + gy*gy);

                    // THRESHOLD: If magnitude is high, it's an edge
                    if (mag > 40) { 
                        // Draw Green Pixel in Output
                        // Adjust index for output buffer
                        const outIdx = (y * width + x) * 4;
                        output.data[outIdx] = 0;   // R
                        output.data[outIdx+1] = 255; // G (Green)
                        output.data[outIdx+2] = 0;   // B
                        output.data[outIdx+3] = 255; // Alpha
                    }
                }
            }

            // Put the edge data back onto the main canvas
            // Use a temporary canvas to overlay it cleanly
            const edgeCanvas = document.createElement('canvas');
            edgeCanvas.width = rw;
            edgeCanvas.height = rh;
            edgeCanvas.getContext('2d').putImageData(output, 0, 0);
            
            ctx.drawImage(edgeCanvas, startX, startY);
            
            // Draw Face ID
            ctx.font = "bold 20px Consolas";
            ctx.fillStyle = "#00ff00";
            ctx.fillText(`TARGET`, face.x - 20, face.y - 60);
        }

        function generateReport(face, id) {
            const seed = Math.floor(face.x * face.y);
            const tiers = ["HTN", "MTN", "LTN", "CHAD"];
            const tier = tiers[seed % 4];
            
            const html = `
                <div class="report-card">
                    <div class="stat"><strong>SUBJECT ID</strong> <span>00${id}</span></div>
                    <div class="stat"><strong>SILHOUETTE INTEGRITY</strong> <span>${(80 + seed%19)}%</span></div>
                    <div class="stat"><strong>EST. CLASSIFICATION</strong> <span>${tier}</span></div>
                    <div style="font-size:0.7em; color:#666; margin-top:5px;">
                        Gradient analysis completed on localized ROI.
                    </div>
                </div>
            `;
            reportArea.insertAdjacentHTML('beforeend', html);
        }

    </script>
</body>
</html>

